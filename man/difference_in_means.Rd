% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/difference_in_means.R
\name{difference_in_means}
\alias{difference_in_means}
\title{Built-in Estimators: Difference-in-means}
\usage{
difference_in_means(formula, blocks, clusters, condition1 = NULL,
  condition2 = NULL, data, weights, subset, alpha = 0.05)
}
\arguments{
\item{formula}{An object of class "formula", such as Y ~ Z}

\item{blocks}{An optional bare (unquoted) name of the block variable. Use for blocked designs only.}

\item{clusters}{An optional bare (unquoted) name of the variable that corresponds to the clusters in the data; used for cluster randomized designs. For blocked designs, clusters must be within blocks.}

\item{condition1}{names of the conditions to be compared. Effects are estimated with condition1 as control and condition2 as treatment. If unspecified, condition1 is the "first" condition and condition2 is the "second" according to r defaults.}

\item{condition2}{names of the conditions to be compared. Effects are estimated with condition1 as control and condition2 as treatment. If unspecified, condition1 is the "first" condition and condition2 is the "second" according to r defaults.}

\item{data}{A data.frame.}

\item{weights}{An optional bare (unquoted) name of the weights variable.}

\item{subset}{An optional bare (unquoted) expression specifying a subset of observations to be used.}

\item{alpha}{The significance level, 0.05 by default.}
}
\description{
Built-in Estimators: Difference-in-means
}
\details{
This function implements difference-in-means estimation, with and without blocking. Standard errors are estimated as the square root of the sum of the within-group variances, divided by their respective sample sizes (Equation 3.6 in Gerber and Green 2012). If blocked, the difference in means estimate is taken in each block, then averaged together according to block size.
}
\examples{

 library(fabricatr)
 library(randomizr)
 # Get appropriate standard errors for simple designs
 dat <- fabricate(
   N = 100,
   Y = rnorm(100),
   Z_simp = simple_ra(N, prob = 0.4),
 )

 table(dat$Z_simp)
 difference_in_means(Y ~ Z_simp, data = dat)

 # Accurates estimates and standard errors for clustered designs
 dat$clust <- sample(20, size = nrow(dat), replace = TRUE)
 dat$Z_clust <- cluster_ra(dat$clust, prob = 0.6)

 table(dat$Z_clust, dat$clust)
 difference_in_means(Y ~ Z_clust, clusters = clust, data = dat)

 # Accurate estimates and standard errors for blocked designs
 dat$block <- rep(1:10, each = 10)
 dat$Z_block <- block_ra(dat$block, prob = 0.5)

 table(dat$Z_block, dat$block)
 difference_in_means(Y ~ Z_block, blocks = block, data = dat)

 # Matched-pair estimates and standard errors are also accurate
 # Specified same as blocked design, function learns that
 # it is matched pair from size of blocks!
 dat$pairs <- rep(1:50, each = 2)
 dat$Z_pairs <- block_ra(dat$pairs, prob = 0.5)

 table(dat$pairs, dat$Z_pairs)
 difference_in_means(Y ~ Z_pairs, blocks = pairs, data = dat)

 # Also works with multi-valued treatments if users specify
 # comparison of interest
 dat$Z_multi <- simple_ra(
   nrow(dat),
   condition_names = c("Treatment 2", "Treatment 1", "Control"),
   prob_each = c(0.4, 0.4, 0.2)
 )

 # Only need to specify which condition is treated "condition2" and
 # which is control "condition1"
 difference_in_means(
   Y ~ Z_multi,
   condition1 = "Treatment 2",
   condition2 = "Control",
   data = dat
 )
 difference_in_means(
   Y ~ Z_multi,
   condition1 = "Treatment 1",
   condition2 = "Control",
   data = dat
 )

}
